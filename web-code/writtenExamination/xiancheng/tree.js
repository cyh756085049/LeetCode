/**
 已知有平面坐标系的十组坐标点[[x1,y1], [x2,y2], ……, [x10,y10]]，每次找出距离最近的两组坐标进行合并，合并后的坐标取两者平均值，即[(x1+x2)/2 , (y1+y2)/2]（如有小数统一向下取整，即2.4取2），合并后的新坐标作为二叉树根节点，原坐标取X值较小的作为左节点，另一个为右节点，假设第一次计算后得出[x1,y1], [x2,y2]距离最近，且x1<x2，则构成如下二叉树：
 [(x1+x2)/2, (y1+y2)/2]

 /   \

 /     \

 [x1, y1]    [x2, y2]       [x3, y3] [x4, y4]  ……[x10, y10]

 合并后的新坐标和余下没有在二叉树中的原始坐标构成新数组[[(x1+x2)/2, (y1+y2)/2], [x3,y3],[x4, y4] ……, [x10,y10]]继续重复上述步骤，直至二叉树构建完成，最后按前序优先输出二叉树的数组，假设只有3组坐标的话，可能的一种二叉树场景为：
 [(((x1+x2)/2)+x3]/2, (((y1+y2)/2)+y3]/2]
 /                  \

 /                      \
 [(x1+x2)/2, (y1+y2)/2]      [x3,y3]

 /         \

 /           \
 [x1, y1]    [x2, y2]
 注：两点之间距离的平方公式：(x1-x2)²+(y1-y2)²

 输入：表示平面坐标系中坐标点的二维数组，如int a[10][2]
 输出：前序遍历后的二叉树数据

 [[5,10], [3,15], [10,18]]

 7,15
 4,12
 3,15
 5,10
 10,18
 */

function minDic(dp) {
    const m = dp.length;
    for (let i = 0; i < m; i++) {
        // for (let j = 0; j < )
    }
}
